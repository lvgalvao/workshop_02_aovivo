{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workshop 02 - Data Quality","text":"<p>Para desenvolver o desafio de negocio, vamos montar a seguinte ETL</p>"},{"location":"#fluxo","title":"Fluxo","text":"<pre><code>graph TD;\n    A[Configura Vari\u00e1veis] --&gt; B[Ler o Banco SQL];\n    B --&gt; V[Valida\u00e7\u00e3o do Schema de Entrada];\n    V --&gt;|Falha| X[Alerta de Erro];\n    V --&gt;|Sucesso| C[Transformar os KPIs];\n    C --&gt; Y[Valida\u00e7\u00e3o do Schema de Sa\u00edda];\n    Y --&gt;|Falha| Z[Alerta de Erro];\n    Y --&gt;|Sucesso| D[Salvar no DuckDB];\n</code></pre>"},{"location":"#contrato-de-dados","title":"Contrato de dados","text":"<p>             Bases: <code>SchemaModel</code></p> <p>Define o esquema para a valida\u00e7\u00e3o de dados de produtos com Pandera.</p> <p>Este esquema inclui campos b\u00e1sicos para produtos, incluindo um campo de e-mail validado por uma express\u00e3o regular.</p> <p>Attributes:</p> Name Type Description <code>id_produto</code> <code>Series[int]</code> <p>Identificador do produto, deve estar entre 1 e 20.</p> <code>nome</code> <code>Series[str]</code> <p>Nome do produto.</p> <code>quantidade</code> <code>Series[int]</code> <p>Quantidade dispon\u00edvel do produto, deve estar entre 20 e 200.</p> <code>preco</code> <code>Series[float]</code> <p>Pre\u00e7o do produto, deve estar entre 5.0 e 120.0.</p> <code>categoria</code> <code>Series[str]</code> <p>Categoria do produto.</p> <code>email</code> <code>Series[str]</code> <p>E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.</p> Source code in <code>app\\schema.py</code> <pre><code>class ProdutoSchema(pa.SchemaModel):\n    \"\"\"\n    Define o esquema para a valida\u00e7\u00e3o de dados de produtos com Pandera.\n\n    Este esquema inclui campos b\u00e1sicos para produtos, incluindo um campo de e-mail\n    validado por uma express\u00e3o regular.\n\n    Attributes:\n        id_produto (Series[int]): Identificador do produto, deve estar entre 1 e 20.\n        nome (Series[str]): Nome do produto.\n        quantidade (Series[int]): Quantidade dispon\u00edvel do produto, deve estar entre 20 e 200.\n        preco (Series[float]): Pre\u00e7o do produto, deve estar entre 5.0 e 120.0.\n        categoria (Series[str]): Categoria do produto.\n        email (Series[str]): E-mail associado ao produto, deve seguir o formato padr\u00e3o de e-mails.\n    \"\"\"\n    id_produto: Series[int]\n    nome: Series[str]\n    quantidade: Series[int] = pa.Field(ge=20, le=200)\n    preco: Series[float] = pa.Field(ge=05.0, le=120.0)\n    categoria: Series[str]\n    email: Series[str] = pa.Field(regex=email_regex)\n\n    class Config:\n        coerce = True\n        strict = True\n</code></pre>"},{"location":"#transformacoes","title":"Transformacoes","text":""},{"location":"#configura-variaveis","title":"Configura Vari\u00e1veis","text":"<p>Carrega as configura\u00e7\u00f5es a partir de vari\u00e1veis de ambiente.</p> Source code in <code>app\\etl.py</code> <pre><code>def load_settings():\n    \"\"\"Carrega as configura\u00e7\u00f5es a partir de vari\u00e1veis de ambiente.\"\"\"\n    dotenv_path = Path.cwd() / '.env'\n    load_dotenv(dotenv_path=dotenv_path)\n\n    settings = {\n        \"db_host\": os.getenv(\"POSTGRES_HOST\"),\n        \"db_user\": os.getenv(\"POSTGRES_USER\"),\n        \"db_pass\": os.getenv(\"POSTGRES_PASSWORD\"),\n        \"db_name\": os.getenv(\"POSTGRES_DB\"),\n        \"db_port\": os.getenv(\"POSTGRES_PORT\"),\n    }\n    return settings\n</code></pre>"},{"location":"#ler-o-banco-sql","title":"Ler o Banco SQL","text":"<p>Extrai dados do banco de dados SQL usando a consulta fornecida.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>A consulta SQL para extrair dados.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Um DataFrame do Pandas contendo os dados extra\u00eddos.</p> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_output(ProdutoSchema, lazy=True)\ndef extrair_do_sql(query: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Extrai dados do banco de dados SQL usando a consulta fornecida.\n\n    Args:\n        query: A consulta SQL para extrair dados.\n\n    Returns:\n        Um DataFrame do Pandas contendo os dados extra\u00eddos.\n    \"\"\"\n    settings = load_settings()\n\n    # Criar a string de conex\u00e3o com base nas configura\u00e7\u00f5es\n    connection_string = f\"postgresql://{settings['db_user']}:{settings['db_pass']}@{settings['db_host']}:{settings['db_port']}/{settings['db_name']}\"\n\n    # Criar engine de conex\u00e3o\n    engine = create_engine(connection_string)\n\n    with engine.connect() as conn, conn.begin():\n            df_crm = pd.read_sql(query, conn)\n\n    return df_crm\n</code></pre>"},{"location":"#transformar-os-kpis","title":"Transformar os KPIs","text":"<p>Transforma os dados do DataFrame aplicando c\u00e1lculos e normaliza\u00e7\u00f5es.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame do Pandas contendo os dados originais.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame do Pandas ap\u00f3s a aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.</p> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProdutoSchema, lazy=True)\n@pa.check_output(ProductSchemaKPI, lazy=True)\ndef transformar(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Transforma os dados do DataFrame aplicando c\u00e1lculos e normaliza\u00e7\u00f5es.\n\n    Args:\n        df: DataFrame do Pandas contendo os dados originais.\n\n    Returns:\n        DataFrame do Pandas ap\u00f3s a aplica\u00e7\u00e3o das transforma\u00e7\u00f5es.\n    \"\"\"\n    # Calcular valor_total_estoque\n    df['valor_total_estoque'] = df['quantidade'] * df['preco']\n\n    # Normalizar categoria para mai\u00fasculas\n    df['categoria_normalizada'] = df['categoria'].str.lower()\n\n    # Determinar disponibilidade (True se quantidade &gt; 0)\n    df['disponibilidade'] = df['quantidade'] &gt; 0\n\n    return df\n</code></pre>"},{"location":"#salvar-no-duckdb","title":"Salvar no DuckDB","text":"<p>S </p> <p>Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame do Pandas para ser carregado no DuckDB.</p> required <code>table_name</code> <code>str</code> <p>Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.</p> required <code>db_file</code> <code>str</code> <p>Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.</p> <code>'my_duckdb.db'</code> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProductSchemaKPI, lazy=True)\ndef load_to_duckdb(df: pd.DataFrame, table_name: str, db_file: str = 'my_duckdb.db'):\n    \"\"\"\n    Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especificada.\n\n    Args:\n        df: DataFrame do Pandas para ser carregado no DuckDB.\n        table_name: Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.\n        db_file: Caminho para o arquivo DuckDB. Se n\u00e3o existir, ser\u00e1 criado.\n    \"\"\"\n    # Conectar ao DuckDB. Se o arquivo n\u00e3o existir, ele ser\u00e1 criado.\n    con = duckdb.connect(database=db_file, read_only=False)\n\n    # Registrar o DataFrame como uma tabela tempor\u00e1ria\n    con.register('df_temp', df)\n\n    # Utilizar SQL para inserir os dados da tabela tempor\u00e1ria em uma tabela permanente\n    # Se a tabela j\u00e1 existir, substitui.\n    con.execute(f\"CREATE OR REPLACE TABLE {table_name} AS SELECT * FROM df_temp\")\n\n    # Fechar a conex\u00e3o\n    con.close()\n</code></pre>"}]}